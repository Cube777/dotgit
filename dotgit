#! /bin/bash

# Dotgit is an easy-to-use and effective way to backup all your dotfiles and
# manage them in a repository

# Developer: Kobus van Schoor

REPO="$PWD"
NORMFILES=""
CRYPTFILES=""
DOTFILES=""
DMZ=""
PASSWD=""

function cfilelist
{
	NORMFILES=$(grep -v '^#' "$REPO/filelist" | grep -v "^$")
	CRYPTFILES=$(grep -v '^#' "$REPO/cryptlist" | grep -v "^$")
	DOTFILES="$REPO/dotfiles"
	DMZ="$REPO/dmz"
}

function phelp
{
	echo 'Usage: dotgit [option] (optional args)

  To make a new dotgit repository first create your online repository, and then
  clone it onto your target host (git clone {repo_url} {repo_dest}). Go into
  your repository and then run dotgit init inside of it. The repository will
  then be ready to be used with dotgit.

  If you already have a dotgit repository and would like to use it on another
  host, simply clone the repository onto the target host and the repository will
  be ready to use with dotgit.

Filelist syntax:
  #--hard--#          --  Do not use symlinks, see below for more details
  .bashrc             --  Will be in "common" folder and will be restored to
                          home folder, regardless of hostname (unless category
                          is specified)
  .vimrc:host1,host2  --  Will only be restored if hostname of machine matches
                          "host1" or "host2"
  .vimrc:host3        --  Will be kept seperate from .vimrc above and will only
                          be restored on host3
  .xinitrc:category1  --  When category1 is specified as category only files
                          with category1 suffix will be restored (or backed up)
                          (also excludes common folder)

  Categories and host use exactly the same syntax. This also means that you can
  specify a file to belong to multiple categories (and keep them synced)
  Comments are indicated with a # at the begining of the line, comments at the
  end of a line is not yet supported

  After making any changes to the filelist you should run dotgit update, commit
  and push your changes and then run dotgit restore on all other hosts you use
  This ensures that the symlinking hierarchy stays up-to-date

  If you prefer not to use symlinks in your home dir (eg. if the repo will not
  live on on the host or because of special filesystem setups) you have to
  options. If you only want to copy the dotfiles once you can use the "hard"
  versions of the various operations described below. If you want a long-term
  solution simply add a line to your filelist only containing "#--hard--#"
  without the qoutes. This will cause dotgit to simply invoke the "hard"
  versions of the operation automatically when using their normal couterparts
  (eg "dotgit update" will now be equivalent to "dotgit hard-update"). To see
  what operations will be affected by this option see below.

OPTIONS:
  If an argument is passed to the relevant functions only files pertaining to
  that category or hostname will be taken into account

  update (arg)        --  If new files are added to the filelist, copy them to
                          the repository and set up links in home folder
                          If any changes are made to the filelist you should run
                          dotgit with the update option to keep symlinks
                          up-to-date
                          #--hard--#: Will copy files into repository and
                          leave the files in the home dir intact
  restore (arg)       --  Set up links in home folder to repository
                          #--hard--#: Same as hard-restore
  generate            --  Generate a commit message, commit changes and push to
                          remote
  hard-restore (arg)  --  Make a copy from the dotgit repository into home dir
  init                --  Initialize current folder with new dotgit repo (create
                          empty filelist and dotfiles folder)
  diff                --  Show what files changed from previous commit in dotgit
                          repository
  help                --  Show this message'
}

function safeguards
{
	if [ $1 == "init" ]; then
		return
	fi

	if [ "$REPO" == "$HOME" ]; then
		echo "You shouldn't run this in your home folder, make a seperate" \
		"folder for your dotfiles"
		exit 1
	fi

	if [ ! -f "$REPO/filelist" ]; then
		echo "Filelist not found. Aborting..."
		exit 1
	fi

	if [ ! -d "$REPO/.git" ]; then
		echo "This does not seem to be a git repository. Aborting..."
		exit 1
	fi

	if ! grep -q -v "#" "$REPO/filelist"; then
		echo "Filelist empty. Aborting..."
		exit 1
	fi

	if grep -q "//" "$REPO/filelist"; then
		echo "Converting filelist to new comment syntax (// -> #)..."
		sed -i "s/\/\//#/g" "$REPO/filelist"
	fi

	if [ ! -d "$REPO/dotfiles" ]; then
		echo "Dotfiles folder not found. Aborting..."
		exit 1
	fi
}

function pstatus
{
	type="Adding"
	if [ -n "$3" ]; then
		type="$3"
	fi;

	printf "%-15s" "-->$type"; printf "%-20s" $2 $1; printf "\n"
}

function pprompt
{
	echo -n "Please enter a password for $1 (nothing will be shown): "
	stty -echo
	read ans
	stty echo
	echo ""
	PASSWD=$ans
	echo $PASSWD > $REPO/tmp
}

function encrypt
{
	cd "$DMZ"
	for i in $(find -type l); do
		if [ -f "$DOTFILES/$i" ]; then
			rm "$DOTFILES/$i"
		fi
		cp -P --parents "$i" "$DOTFILES"
	done

	if [ -z "$PASSWD" ]; then
		pprompt "encryption"
	fi

	for i in $(find -not -type d -and -not -type l); do
		echo "-->Encrypting $(echo $i | cut -c 3-)"
		mkdir -p $(dirname "$DOTFILES/$i")
		if [ -f "$DOTFILES/$i" ]; then
			rm "$DOTFILES/$i"
		fi
		gpg -c --batch --passphrase-file "$REPO/tmp" -o "$DOTFILES/$i" "$i"
	done
}

function update
{
	echo "Commencing normal files update..."
	symlink "$NORMFILES" "$DOTFILES" "$1"
	echo "Commencing encrypted files update..."
	symlink "$CRYPTFILES" "$DMZ" "$1"
	cd $REPO
	if git diff --exit-code "$REPO/cryptlist" > /dev/null; then
		if ! yesno "The cryptlist has changed since the last commit. Would you"\
" like to encrypt the changes? [Y/n]: "; then
			encrypt "$1"
		fi
	fi
}

function hardUpdate
{
	echo "Commencing hard update..."
	cd $HOME
	owner=$1

	if [ -z "$1" ]; then
		for i in $(echo $FILELIST | grep -v "\:"); do
			pstatus $i "common" "Copying"
			if [ ! "$HOME/$i" -ef "$REPO/dotfiles/common/$i" ]; then
				cp -L --parents "$i" "$REPO/dotfiles/common"
			fi
		done;
		owner=$HOSTNAME
	fi

	for i in $(echo $FILELIST | grep "$owner"); do
		ownrs=($(echo $i | rev | sed s/\:.*// | sed s/\,/\\n/g | rev))
		filename=$(echo $i | sed s/\:.*//)

		for k in "${ownrs[@]}"; do
			if [ ! -d "$REPO/dotfiles/$k" ]; then mkdir "$REPO/dotfiles/$k"; fi

			pstatus "$filename" "$k" "Copying"
			if [ -h "$REPO/dotfiles/$k/$filename" ]; then
				rm "$REPO/dotfiles/$k/$filename"
			fi
			if [ ! "$HOME/$filename" -ef "$REPO/dotfiles/$k/$filename" ]; then
				cp -L --parents "$filename" "$REPO/dotfiles/$k"
			fi
		done
	done

	cd $REPO
	cleanup
}

function symlink
{
	FILELIST=$1
	CDFILES=$2
	if grep "#--hard--#" "$REPO/filelist" >> /dev/null ; then
		hardUpdate; exit; fi

	cd $HOME;
	owner=$3

	if [ -z "$owner" ]; then
		for i in $(echo $FILELIST | grep -v "\:"); do
			if [ ! -f "$CDFILES/common/$i" ]; then
				pstatus $i "common"
				cp -L --parents "$i" "$CDFILES/common"
			fi
		done;
		owner=$HOSTNAME
	fi

	for i in $(echo $FILELIST | grep "$owner"); do
		ownrs=($(echo $i | rev | sed s/\:.*// | sed s/\,/\ /g | rev))
		filename=$(echo $i | sed s/\:.*//)
		ownrs=($(for z in ${ownrs[@]}; do echo $z; done | sort))

		splits=$(find "$CDFILES" -lname "*${ownrs[0]}/$filename")
		for k in $(seq 0 `expr ${#ownrs[@]} - 1`); do
			splits=$(echo "$splits" | grep -v "${ownrs[$k]}")
		done

		if [ -n "$splits" ] && [ -f "$CDFILES/${ownrs[0]}/$filename" ]
		then
			for k in $splits; do
				temp="$CDFILES/"
				z=$(echo $k | cut -c $(expr ${#temp} + 1)- | sed "s/\/.*//g")
				pstatus "$filename" "$z" "Splitting"

				rm $k
				cp "$CDFILES/${ownrs[0]}/$filename" $k
			done
		fi

		for k in $(seq 0 `expr ${#ownrs[@]} - 1`); do

			if [ ! -d "$CDFILES/${ownrs[$k]}" ]; then
				mkdir "$CDFILES/${ownrs[$k]}"; fi

			if [ ! -f "$CDFILES/${ownrs[$k]}/$filename" ]; then
				if [ $k == "0" ]; then
					pstatus "$filename" "${ownrs[0]}"
					cp -L --parents "$filename" "$CDFILES/${ownrs[0]}"

					rm "$HOME/$filename"
				else
					pstatus "(${ownrs[0]})  $filename" "${ownrs[$k]}" "Linking"
					mkdir -p "$(dirname "$CDFILES/${ownrs[$k]}/$filename")"
					ln -rs "$CDFILES/${ownrs[0]}/$filename" \
					"$CDFILES/${ownrs[$k]}/$filename"
				fi
			else
				if [ "$k" == "0" ] && \
					[ -h "$CDFILES/${ownrs[$k]}/$filename" ]; then
					pstatus "$filename" "${ownrs[0]}"
					rm "$CDFILES/${ownrs[$k]}/$filename"
					cp -L --parents "$filename" "$CDFILES/${ownrs[$k]}"
				fi

				if [ "$k" != "0" ] && \
					[ ! -h "$CDFILES/${ownrs[$k]}/$filename" ]; then

					if diff "$CDFILES/${ownrs[0]}/$filename" \
						"$CDFILES/${ownrs[$k]}/$filename" > /dev/null;then
						rm "$CDFILES/${ownrs[$k]}/$filename"
						ln -rs "$CDFILES/${ownrs[0]}/$filename" \
							"$CDFILES/${ownrs[$k]}/$filename"
						continue
					fi

					pstatus "$filename" "varies" "Merging"
					echo "Different versions of the same file are now being" \
					"linked together. Which version do you want to use?"

					mergers=()
					for z in $(seq 0 `expr ${#ownrs[@]} - 1`); do
						if [ -f "$CDFILES/${ownrs[$z]}/$filename" ]; then
							mergers=(${mergers[@]} ${ownrs[$z]})
						fi
					done

					for z in $(seq 0 `expr ${#mergers[@]} - 1`); do
						echo "$(expr $z + 1)) ${mergers[$z]}"
					done

					ans=""
					while true; do
						echo -ne "\nYour answer (1-${#mergers[@]}): "
						read ans

						if ! [[ $ans =~ ^[0-9]+$ ]]; then
							echo "Please enter a number"
							continue
						fi

						if [ $ans -ge 1 ] && [ $ans -le ${#mergers[@]} ]; then
							break
						else
							echo "Invalid option, please enter a number "\
								"between 1 and ${#mergers[@]}"
						fi
					done
					ans=`expr $ans - 1`

					if [ $ans -ne 0 ]; then
						rm "$CDFILES/${ownrs[0]}/$filename"
						cp "$CDFILES/${ownrs[$ans]}/$filename" \
							"$CDFILES/${ownrs[0]}/$filename"
					fi

					for z in $(seq 1 `expr ${#ownrs[@]} - 1`); do
						rm "$CDFILES/${ownrs[$z]}/$filename"
					done

					pstatus "(${ownrs[0]}) $filename" "${ownrs[$k]}" "Linking"
					if [ -f "$CDFILES/${ownrs[$k]}/$filename" ]; then
						rm "$CDFILES/${ownrs[$k]}/$filename"
					fi
					ln -rs "$CDFILES/${ownrs[0]}/$filename" \
					"$CDFILES/${ownrs[$k]}/$filename"
				fi

				if [ "$k" != "0" ] && \
					[ -h "$CDFILES/${ownrs[$k]}/$filename" ]; then
					rm "$CDFILES/${ownrs[$k]}/$filename"
					ln -rs "$CDFILES/${ownrs[0]}/$filename" \
					"$CDFILES/${ownrs[$k]}/$filename"
				fi
			fi
		done;
	done;
}

function yesno
{
	echo -n "$1"
	read ans

	if [ "$ans" == "Y" ] || [ "$ans" == "y" ] || [ -z "$ans" ]; then
		return 1
	else
		return 0
	fi
}

function lnconf
{
	if [ -h "$2" ]; then
		rm "$2"
	fi

	if [ -f "$2" ] && [ ! -h "$2" ]; then
		yesno "File $3 already exists in home directory. Do you want to "\
"overwrite it? [Y/n] "

		if [ "$?" == 1 ]; then
			rm "$2"
		else
			return
		fi
	fi
	ln -s "$1" "$2"
}

function restore
{
	echo "Cleaning up old repo links..."
	for i in $(find $HOME -type l -not -wholename "$REPO/*"); do
		if [[ `readlink $i` =~ $REPO ]]; then rm $i; fi
	done

	echo "Commencing unencrypted repo linking..."
	homelink "$NORMFILES" "$DOTFILES" "$1"
	echo "Commencing encrypted repo linking..."
	homelink "$CRYPTFILES" "$DMZ" "$1"
}

function homelink
{
	FILELIST=$1
	CDFILES=$2
	if grep "#--hard--#" "$REPO/filelist" > /dev/null; then
		hardRestore; exit;
	fi

	cd "$CDFILES"
	owner=$3

	if [ -z "$owner" ]; then
		for i in $(echo $FILELIST | grep -v "\:"); do
			if [ "$(dirname "$i")" != "." ]; then
				mkdir -p "$(dirname "$HOME/$i")"
			fi

			if [ ! -f "$CDFILES/common/$filename" ]; then
				echo "-->Can't link $filename (does not seem to be decrypted"\
"yet)"
				continue
			fi

			lnconf "$CDFILES/common/$i" "$HOME/$i" "$i"
		done
		owner=$HOSTNAME
	fi

	for i in $(echo $FILELIST | grep "$owner"); do
		ownrs=($(echo $i | rev | sed s/\:.*// | sed s/\,/\ /g | rev))
		ownrs=($(for z in ${ownrs[@]}; do echo $z; done | sort))
		filename=$(echo $i | sed s/\:.*//);

		if [ ! -f "$CDFILES/${ownrs[0]}/$filename" ]; then
			echo "-->Can't link $filename (does not seem to be decrypted yet)"
			continue
		fi

		if [ "$(dirname "$filename")" != "." ]; then
			mkdir -p "$(dirname "$HOME/$filename")"
		fi

		lnconf "$CDFILES/${ownrs[0]}/$filename" "$HOME/$filename" \
		"$filename"
	done
}

function generate
{
	message="Changes:"
	git add --all
	for i in $(git status --porcelain | grep dotfiles); do
		case "$(echo $i | cut -c 1-1)" in
			"D")message=$(echo "$message deleted $(echo $i | cut -c 13-);");;
			"M")message=$(echo "$message modified $(echo $i | cut -c 13-);");;
			"A")message=$(echo "$message added $(echo $i | cut -c 13-);");;
			"R")message=$(echo "$message renamed $(echo $i | cut -c 4- | sed \
				's/dotfiles\///g');");;
			"C")message=$(echo "$message copied $(echo $i | cut -c 4- | sed \
				's/dotfiles\///g');");;
			"T")message=$(echo "$message typechange $(echo $i | cut -c 13-);");;
		esac
	done
	if [ "$message" == "Changes:" ]; then
		echo "No changes to repository..."
		exit
	fi
	message=$(echo $message | rev | cut -c 2- | rev)
	git commit -m "$message"

	if [ -n "$(git remote -v)" ]; then
		yesno "Remote detected, do you want to push (sync) to it? [Y/n] "
		if [ "$?" == 1 ]; then
			git push
		fi
	fi
}

function cleanup
{
	echo "Commencing cleanup..."

	cd "$REPO/dotfiles"
	for i in *; do
		echo "Cleanup - entering $i..."
		cd "$i"

		for k in $(find -not -type d); do
			if [ $k == "." ]; then
				continue;
			fi
			k=$(echo $k | cut -c 3-);

			z=""
			if [ "$i" != "common" ]; then
				z="$i"
			fi

			if [ -z "$(echo $FILELIST | grep "$k" | grep "$z" )" ]; then
				pstatus "$i/$k" "$i" "Removing"
				rm "$k"
			fi;
		done;
		cd ..
	done;

	cd $REPO;
	find dotfiles -empty -type d -delete
}

function hardRestore
{
	echo "Commencing hard restore..."
	cd dotfiles

	if [ -z "$1" ]; then
		cd common
		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "common" "Copying"
			if [ -f "$HOME/$i" ]; then
				rm "$HOME/$i"
			fi
			cp --parents "$i" "$HOME"
		done
		cd ..

		if [ -d "$HOSTNAME" ]; then
			cd "$HOSTNAME"
		else
			echo "Folder for $HOSTNAME not found..."
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$HOSTNAME" "Copying"
			if [ -f "$HOME/$i" ]; then
				rm "$HOME/$i"
			fi
			cp -L --parents "$i" "$HOME"
		done
	else
		if [ -d "$1" ]; then
			cd "$1"
		else
			echo "Category $1 not found..."
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$1" "Copying"
			if [ -f "$HOME/$i" ]; then
				rm "$HOME/$i"
			fi
			cp -L --parents "$i" "$HOME"
		done
	fi

	echo "Finished copying..."
}

function init
{
	if [ ! -d ".git" ]; then
		echo "Initializing dotgit repo..."
		mkdir -p dotfiles/common
		mkdir -p dmz/common
		git init
		touch filelist
		touch cryptlist
		echo "dmz" >> .gitignore
		echo "Initialized new dotgit repo in $PWD"
	else
		echo "Creating encryption hooks..."
		echo "dotgit encrypt" >> .git/hooks/pre-commit
		chmod +x .git/hooks/pre-commit
		echo "dotgit decrypt" >> .git/hooks/post-merge
		chmod +x .git/hooks/post-merge
	fi
}

function pdiff
{
	git add --all
	for i in $(git status --porcelain | grep dotfiles); do
		case "$(echo $i | cut -c 1-1)" in
			"D")echo "Deleted $(echo $i | cut -c 13-)";;
			"M")echo "Modified $(echo $i | cut -c 13-)";;
			"A")echo "Added $(echo $i | cut -c 13-)";;
			"R")echo "Renamed $(echo $i | cut -c 4- | sed "s/dotfiles\///g")";;
		esac
	done
	git reset -q
}

if [[ $# -eq 0 ]]; then
	phelp;
	exit;
fi;

safeguards $1
if [[ $1 != "init" ]]; then cfilelist; fi

case "$1" in
	"update")update "$2";;
	"restore")restore "$2";;
	"generate")generate;;
	"hard-restore")hardRestore "$2";;
	"init")init;;
	"encrypt")encrypt;;
	"decrypt")decrypt;;
	"diff")pdiff;;
	"help")phelp;;
	*)echo -e "\n$1 is not a valid argument.\n"; phelp; exit 1;;
esac;

if [ -f "$REPO/tmp" ]; then
	rm "$REPO/tmp"
fi
