#! /bin/bash

# Dotgit is an easy-to-use and effective way to backup all your dotfiles and manage them in a repository

# Written by Kobus van Schoor
# You are free to distrubute and modify this software in any way as long as you acknowledge the original author

REPO="$PWD"
OLDIFS=$IFS
IFS=$(echo -ne "\n\b")

function phelp
{
	echo "Usage: dotgit [option] (optional args)

Filelist syntax:
  .bashrc             --  Will be in \"common\" folder and will be restored to home folder, regardless of hostname (unless category is specified)
  .vimrc:host1,host2  --  Will only be restored if hostname of machine matches \"host1\" or \"host2\"
  .vimrc:host3        --  Will be kept seperate from .vimrc above and will only be restored on host3
  .xinitrc:category1  --  When category1 is specified as category only files with category1 suffix will be restored (or backed up) (also excludes common folder)
  Comments are indicated with a // in the begining of the line (any line including // will be ignored, so don't use comments at the end of a line)

OPTIONS:
  update        --  If new files are added to the filelist, copy them to the repository and set up links in home folder
                    If a category is passed as an argument only the category's changes in the filelist will be taken into account
  restore       --  Set up links from repository in home folder
                    If a category is passed as an argument only the category's files will be linked into home folder
  generate      --  Generate a commit message, commit changes and push to remote
  hard-restore  --  Make a hard copy from the dotgit repository into home folder.
                    If a category is specified only the category will be copied into home folder
  add-remote    --  Add a url for an online repository to push (sync) files to (example https://github.com/Cube777/dotfiles)
  init          --  Initialize current folder with new dotgit repo (create empty filelist and dotfiles folder)
  diff          --  Show what files changed from previous commit in dotgit repository
  help          --  Show this message"
}

function safeguards
{
	if [ ! -e "$REPO/filelist" ]; then
		echo "Filelist not found. Aborting..."
		exit;
	fi;

	if [ -z "$(grep -v "//" "$REPO/filelist")" ]; then
		echo "Filelist empty. Aborting..."
		exit
	fi

	if [ ! -d "$REPO/dotfiles" ]; then
		echo "Dotfiles folder not found. Aborting..."
		exit
	fi
}

function pstatus
{
	type="Adding"
	if [ -n "$3" ]; then
		type="$3"
	fi;

	echo -n "-->$type    "; printf "%-30s" $1 $2; printf "\n"
}

function update
{
	safeguards
	echo "Commencing filelist update..."
	cd $HOME;

	if [ -z "$1" ]; then
		for i in $(grep -v "//" "$REPO/filelist" | grep -v "\:"); do
			if [ ! -f "$REPO/dotfiles/common/$i" ]; then
				pstatus $i "common"
				cp --parents "$i" "$REPO/dotfiles/common"

				rm "$HOME/$i"
				ln -s "$REPO/dotfiles/common/$i" "$HOME/$i"
			fi
		done;

		for i in $(grep -v "//" "$REPO/filelist" | grep "$HOSTNAME"); do
			hosts=($(echo $i | rev | sed s/\:.*// | sed s/\,/\\n/g | rev))
			filename=$(echo $i | sed s/\:.*//)
			for k in $(seq 0 `expr ${#hosts[@]} - 1`); do

				if [ ! -d "$REPO/dotfiles/${hosts[$k]}" ]; then mkdir "$REPO/dotfiles/${hosts[$k]}"; fi

				if [ ! -f "$REPO/dotfiles/${hosts[$k]}/$filename" ]; then
					if [ $k == "0" ]; then
						pstatus "$filename" "${hosts[0]}"
						cp --parents "$filename" "$REPO/dotfiles/${hosts[0]}"

						rm "$HOME/$filename"
						ln -s "$REPO/dotfiles/${hosts[0]}/$filename" "$HOME/$filename"
					else
						pstatus "$filename" "${hosts[$k]} (${hosts[0]})" "Linking"
						ln -s "$REPO/dotfiles/${hosts[0]}/$filename" "$REPO/dotfiles/${hosts[$k]}/$filename"
					fi
				fi
			done;
		done;
	else
		if [ ! -d "$REPO/dotfiles/$1" ]; then
			mkdir "$REPO/dotfiles/$1"
		fi

		for i in $(grep -v "//" "$REPO/filelist" | grep "$1"); do
			i=$(echo $i | sed s/\:.*//)
			if [ ! -f "$REPO/dotfiles/$1/$i" ]; then
				pstatus "$i" "$1"
				cp --parents "$i" "$REPO/dotfiles/$1"

				rm "$HOME/$i"
				ln -s "$REPO/dotfiles/$1/$i" "$HOME/$i"
			fi
		done
	fi

	cd $REPO;
	cleanup
}

function lnconf
{
	if [ -f "$2" ]; then
		echo -n "File $3 already exists in home directory. Do you want to overwrite it? [N/y] "
		read ans

		if [ $ans == "Y" ] || [ $ans == "y" ]; then
			rm "$2"
		else
			return
		fi
	fi
	ln -s "$1" "$2"
}

function restore
{
	safeguards
	echo "Commencing repo linking..."
	cd "$REPO/dotfiles"

	if [ -z "$1" ]; then
		for i in $(grep -v "//" "$REPO/filelist" | grep -v "\:"); do
			if [ "$(dirname "$i")" != "." ]; then
				mkdir -p "$(dirname "$i")"
			fi

			lnconf  "$REPO/dotfiles/common/$i" "$HOME/$i" "$i"
		done

		for i in $(grep -v "//" "$REPO/filelist" | grep "$HOSTNAME"); do
			filename=$(echo $i | sed s/\:.*//);
			if [ "$(dirname "$filename")" != "." ]; then
				mkdir -p "$(dirname "$filename")"
			fi

			lnconf "$REPO/dotfiles/$HOSTNAME/$filename" "$HOME/$filename" "$filename"
		done
	else
		for i in $(grep -v "//" "$REPO/filelist" | grep "$1"); do
			filename=$(echo $i | sed s/\:.*//);
			if [ "$(dirname "$filename")" != "." ]; then
				mkdir -p "$(dirname "$filename")"
			fi

			lnconf "$REPO/dotfiles/$1/$filename" "$HOME/$filename" "$filename"
		done
	fi
}

function generate
{
	message="Changes: "
	for i in $(git status --porcelain | grep dotfiles); do
		case "$(echo $i | cut -c 1-1)" in
			"D")message=$(echo "$message deleted $(echo $i | cut -c 13-); ");;
			"M")message=$(echo "$message modified $(echo $i | cut -c 13-); ");;
			"A")message=$(echo "$message added $(echo $i | cut -c 13-); ");;
			"R")message=$(echo "$message renamed $(echo $i | cut -c 4- | sed "s/dotfiles\///g"); ");;
		esac
	done
	message=$(echo $message | rev | cut -c 2- | rev)
	git commit -q -m "$message"

	if ! git remote >> /dev/null; then
		echo -n "Remote detected, do you want to push (sync) to it? [Y/n] "
		read ans
		if [ -z "$ans" ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
			for i in $(git remote); do
				git push -q -u $i "$(git branch | grep \* | cut -c 3-)"
			done;
		fi
	fi
}

function cleanup
{
	echo "Commencing cleanup..."

	cd dotfiles
	for i in *; do
		echo "Entering $i..."
		cd "$i"

		for k in $(find -not -type d); do
			if [ $k == "." ]; then
				continue;
			fi
			k=$(echo $k | cut -c 3-);

			z=""
			if [ $i != "common" ]; then
				z="$i"
			fi

			if [ -z "$(grep -v "//" "$REPO/filelist" | grep "$k" | grep "$z" )" ]; then
				pstatus "$k" "$i" "Removing"
				rm "$k"
			fi;
		done;
		cd ..
	done;

	cd $REPO;
	find dotfiles -empty -type d -delete
}

function confcpy
{
	if [ -f "$HOME/$1" ]; then
		if [ ! -z "$(diff "$i" "$HOME/$i")" ]; then
			echo -ne "File $1 already exist in $HOME, and differs from the one in this repository.\nDo you want to replace it? [N/y]: "
			read ans
			if [ $ans == "y" ] || [ $ans == "Y" ]; then
				cp --parents "$1" "$HOME"
			fi
		fi
	else
		cp --parents "$1" "$HOME"
	fi
}

function hardRestore
{
	echo "Commencing hard restore..."
	cd dotfiles

	if [ -z "$1" ]; then
		cd common
		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "common" "Copying"
			cp --parents "$i" "$HOME"
		done
		cd ..

		if [ -d "$HOSTNAME" ]; then
			cd "$HOSTNAME"
		else
			echo "Folder for $HOSTNAME not found..."
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$HOSTNAME" "Copying"
			cp --parents "$i" "$HOME"
		done
	else
		if [ -d "$1" ]; then
			cd "$1"
		else
			echo "Category $1 not found..."
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$1" "Copying"
			cp --parents "$i" "$HOME"
		done
	fi

	echo "Finished copying..."
}

function init
{
	echo "Initializing dotgit repo..."
	mkdir dotfiles
	mkdir dotfiles/common
	git init
	touch filelist
	echo "Initialized new dotgit repo in $PWD"
}

function pdiff
{
	for i in $(git status --porcelain | grep dotfiles); do
		case "$(echo $i | cut -c 1-1)" in
			"D")echo "Deleted $(echo $i | cut -c 13-)";;
			"M")echo "Modified $(echo $i | cut -c 13-)";;
			"A")echo "Added $(echo $i | cut -c 13-)";;
			"R")echo "Renamed $(echo $i | cut -c 4- | sed "s/dotfiles\///g")";;
		esac
	done
}

function addRemote
{
	if [ -z "$1" ]; then
		echo "Error: you need to specify a remote repo"
		return
	fi

	if [ ! -z "$(git remote)" ]; then
		echo -n "This repository already has a remote repository to sync to (remote name $(git remote)), remove it? [Y/n] "
		read ans
		if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
			echo "Removed $(git remote)"
			git remote remove $(git remote)
		else
			echo "Aborting..."
			return
		fi
	fi

	git remote add origin "$1"
	echo "Added new repository $1"
}


if [[ $# -eq 0 ]]; then
	phelp;
	exit;
fi;

case "$1" in
	"update")update "$2";;
	"restore")restore "$2";;
	"generate")generate;;
	"hard-restore")hardRestore "$2";;
	"init")init;;
	"diff")pdiff;;
	"help")phelp;;
	"add-remote")addRemote "$2";;
	*)echo -e "\n$1 is not a valid argument.\n"; phelp;;
esac;

IFS=$OLDIFS
