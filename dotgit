#! /bin/bash

# Dotgit is an easy-to-use and effective way to backup all your dotfiles and manage them in a repository

# Written by Kobus van Schoor
# You are free to distrubute and modify this software in any way as long as you acknowledge the original author

REPO="$PWD"
OLDIFS=$IFS
IFS=$(echo -ne "\n\b")

function phelp
{
	echo "Usage: dotgit [option] (optional args)

Filelist syntax:
  .bashrc             --  Will be in \"common\" folder and will be restored to home folder, regardless of hostname (unless category is specified)
  .vimrc:host1,host2  --  Will only be restored if hostname of machine matches \"host1\" or \"host2\"
  .vimrc:host3        --  Will be kept seperate from .vimrc above and will only be restored on host3
  .xinitrc:category1  --  When category1 is specified as category only files with category1 suffix will be restored (or backed up) (also excludes common folder)

  Categories and host use exactly the same syntax. This also means that you can specify a file to belong to multiple categories (and keep them synced)
  Comments are indicated with a // in the begining of the line (any line including // will be ignored, so don't use comments at the end of a line)

OPTIONS:
  If an argument is passed to the relevant functions only files pertaining to that category or hostname will be taken into account

  update (arg)        --  If new files are added to the filelist, copy them to the repository and set up links in home folder
                          If any changes are made to the filelist you should run dotgit with the update option to keep symlinks up-to-date
  restore (arg)       --  Set up links in home folder to repository
  generate            --  Generate a commit message, commit changes and push to remote
  hard-restore (arg)  --  Make a copy from the dotgit repository into home folder.
  add-remote (url)    --  Add a url for an online repository to push (sync) files to (example https://github.com/Cube777/dotfiles)
  init                --  Initialize current folder with new dotgit repo (create empty filelist and dotfiles folder)
  diff                --  Show what files changed from previous commit in dotgit repository
  help                --  Show this message"
}

function safeguards
{
	if [ "$REPO" == "$HOME" ]; then
		echo "You shouldn't run this in your home folder, make a seperate folder for your dotfiles"
		exit
	fi

	if [ ! -e "$REPO/filelist" ]; then
		echo "Filelist not found. Aborting..."
		exit;
	fi;

	if [ -z "$(grep -v "//" "$REPO/filelist")" ]; then
		echo "Filelist empty. Aborting..."
		exit
	fi

	if [ ! -d "$REPO/dotfiles" ]; then
		echo "Dotfiles folder not found. Aborting..."
		exit
	fi
}

function pstatus
{
	type="Adding"
	if [ -n "$3" ]; then
		type="$3"
	fi;

	printf "%-30s" "-->$type"; printf "%-30s" $1 $2; printf "\n"
}

function update
{
	safeguards
	echo "Commencing filelist update..."
	cd $HOME;
	owner=$1

	if [ -z "$1" ]; then
		for i in $(grep -v "//" "$REPO/filelist" | grep -v "\:"); do
			if [ ! -f "$REPO/dotfiles/common/$i" ]; then
				pstatus $i "common"
				cp --parents "$i" "$REPO/dotfiles/common"

				rm "$HOME/$i"
				ln -s "$REPO/dotfiles/common/$i" "$HOME/$i"
			fi
		done;
		owner=$HOSTNAME
	fi

	for i in $(grep -v "//" "$REPO/filelist" | grep "$owner"); do
		ownrs=($(echo $i | rev | sed s/\:.*// | sed s/\,/\\n/g | rev))
		filename=$(echo $i | sed s/\:.*//)
		ownrs=($(for z in ${ownrs[@]}; do echo $z; done | sort))
		for k in $(seq 0 `expr ${#ownrs[@]} - 1`); do

			if [ ! -d "$REPO/dotfiles/${ownrs[$k]}" ]; then mkdir "$REPO/dotfiles/${ownrs[$k]}"; fi

			if [ ! -f "$REPO/dotfiles/${ownrs[$k]}/$filename" ]; then
				if [ $k == "0" ]; then
					pstatus "$filename" "${ownrs[0]}"
					cp -L --parents "$filename" "$REPO/dotfiles/${ownrs[0]}"

					rm "$HOME/$filename"
					ln -s "$REPO/dotfiles/${ownrs[0]}/$filename" "$HOME/$filename"
				else
					pstatus "$filename" "${ownrs[$k]} (${ownrs[0]})" "Linking"
					mkdir -p "$(dirname "$REPO/dotfiles/${ownrs[$k]}/$filename")"
					ln -rs "$REPO/dotfiles/${ownrs[0]}/$filename" "$REPO/dotfiles/${ownrs[$k]}/$filename"
				fi
			else
				if [ "$k" == "0" ] && [ -h "$REPO/dotfiles/${ownrs[$k]}/$filename" ]; then
					rm "$REPO/dotfiles/${ownrs[$k]}/$filename"
					cp -L --parents "$filename" "$REPO/dotfiles/${ownrs[$k]}"

					rm "$HOME/$filename"
					ln -s "$REPO/dotfiles/${ownrs[0]}/$filename" "$HOME/$filename"
				fi

				if [ "$k" != "0" ] && [ ! -h "$REPO/dotfiles/${ownrs[$k]}/$filename" ]; then
					pstatus "$filename" "${ownrs[0]}" "Linking"
					rm "$REPO/dotfiles/${ownrs[$k]}/$filename"
					ln -rs "$REPO/dotfiles/${ownrs[0]}/$filename" "$REPO/dotfiles/${ownrs[$k]}/$filename"
				fi

				if [ "$k" != "0" ] && [ -h "$REPO/dotfiles/${ownrs[$k]}/$filename" ]; then
					rm "$REPO/dotfiles/${ownrs[$k]}/$filename"
					ln -rs "$REPO/dotfiles/${ownrs[0]}/$filename" "$REPO/dotfiles/${ownrs[$k]}/$filename"
				fi
			fi
		done;
	done;

	cd $REPO;
	cleanup
}

function lnconf
{
	if [ -h "$2" ]; then
		rm "$2"
	fi

	if [ -f "$2" ] && [ ! -h "$2" ]; then
		echo -n "File $3 already exists in home directory. Do you want to overwrite it? [Y/n] "
		read ans

		if [ "$ans" == "Y" ] || [ "$ans" == "y" ] || [ -z "$ans" ]; then
			rm "$2"
		else
			return
		fi
	fi
	ln -s "$1" "$2"
}

function restore
{
	safeguards
	echo "Commencing repo linking..."
	cd "$REPO/dotfiles"
	owner=$1

	if [ -z "$1" ]; then
		for i in $(grep -v "//" "$REPO/filelist" | grep -v "\:"); do
			if [ "$(dirname "$i")" != "." ]; then
				mkdir -p "$(dirname "$i")"
			fi

			lnconf "$REPO/dotfiles/common/$i" "$HOME/$i" "$i"
		done
		owner=$HOSTNAME
	fi

	for i in $(grep -v "//" "$REPO/filelist" | grep "$owner"); do
		ownrs=($(echo $i | rev | sed s/\:.*// | sed s/\,/\\n/g | rev))
		ownrs=($(for z in ${ownrs[@]}; do echo $z; done | sort))
		filename=$(echo $i | sed s/\:.*//);

		if [ "$(dirname "$filename")" != "." ]; then
			mkdir -p "$(dirname "$filename")"
		fi

		lnconf "$REPO/dotfiles/${ownrs[0]}/$filename" "$HOME/$filename" "$filename"
	done
}

function generate
{
	message="Changes:"
	git add --all
	for i in $(git status --porcelain | grep dotfiles); do
		case "$(echo $i | cut -c 1-1)" in
			"D")message=$(echo "$message deleted $(echo $i | cut -c 13-);");;
			"M")message=$(echo "$message modified $(echo $i | cut -c 13-);");;
			"A")message=$(echo "$message added $(echo $i | cut -c 13-);");;
			"R")message=$(echo "$message renamed $(echo $i | cut -c 4- | sed "s/dotfiles\///g");");;
		esac
	done
	if [ "$message" == "Changes:" ]; then
		echo "No changes to repository..."
		exit
	fi
	message=$(echo $message | rev | cut -c 2- | rev)
	git commit -m "$message"

	if git remote >> /dev/null; then
		echo -n "Remote detected, do you want to push (sync) to it? [Y/n] "
		read ans
		if [ -z "$ans" ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
			git push
		fi
	fi
}

function cleanup
{
	echo "Commencing cleanup..."

	cd dotfiles
	for i in *; do
		echo "Entering $i..."
		cd "$i"

		for k in $(find -not -type d); do
			if [ $k == "." ]; then
				continue;
			fi
			k=$(echo $k | cut -c 3-);

			z=""
			if [ $i != "common" ]; then
				z="$i"
			fi

			if [ -z "$(grep -v "//" "$REPO/filelist" | grep "$k" | grep "$z" )" ]; then
				pstatus "$i/$k" "$i" "Removing"
				rm "$k"
			fi;
		done;
		cd ..
	done;

	cd $REPO;
	find dotfiles -empty -type d -delete
}

function hardRestore
{
	echo "Commencing hard restore..."
	safeguards
	cd dotfiles

	if [ -z "$1" ]; then
		cd common
		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "common" "Copying"
			if [ -f "$HOME/$i" ]; then
				rm "$HOME/$i"
			fi
			cp --parents "$i" "$HOME"
		done
		cd ..

		if [ -d "$HOSTNAME" ]; then
			cd "$HOSTNAME"
		else
			echo "Folder for $HOSTNAME not found..."
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$HOSTNAME" "Copying"
			if [ -f "$HOME/$i" ]; then
				rm "$HOME/$i"
			fi
			cp -L --parents "$i" "$HOME"
		done
	else
		if [ -d "$1" ]; then
			cd "$1"
		else
			echo "Category $1 not found..."
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$1" "Copying"
			if [ -f "$HOME/$i" ]; then
				rm "$HOME/$i"
			fi
			cp -L --parents "$i" "$HOME"
		done
	fi

	echo "Finished copying..."
}

function init
{
	echo "Initializing dotgit repo..."
	mkdir dotfiles
	mkdir dotfiles/common
	git init
	touch filelist
	echo "Initialized new dotgit repo in $PWD"
}

function pdiff
{
	git add --all
	for i in $(git status --porcelain | grep dotfiles); do
		case "$(echo $i | cut -c 1-1)" in
			"D")echo "Deleted $(echo $i | cut -c 13-)";;
			"M")echo "Modified $(echo $i | cut -c 13-)";;
			"A")echo "Added $(echo $i | cut -c 13-)";;
			"R")echo "Renamed $(echo $i | cut -c 4- | sed "s/dotfiles\///g")";;
		esac
	done
	git reset -q
}

function addRemote
{
	if [ -z "$1" ]; then
		echo "Error: you need to specify a remote repo"
		return
	fi

	if [ ! -z "$(git remote)" ]; then
		echo -n "This repository already has a remote repository to sync to (remote name $(git remote)), remove it? [Y/n] "
		read ans
		if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
			echo "Removed $(git remote)"
			git remote remove $(git remote)
		else
			echo "Aborting..."
			return
		fi
	fi

	git remote add origin "$1"
	echo "Added new repository $1"
}


if [[ $# -eq 0 ]]; then
	phelp;
	exit;
fi;

case "$1" in
	"update")update "$2";;
	"restore")restore "$2";;
	"generate")generate;;
	"hard-restore")hardRestore "$2";;
	"init")init;;
	"diff")pdiff;;
	"help")phelp;;
	"add-remote")addRemote "$2";;
	*)echo -e "\n$1 is not a valid argument.\n"; phelp;;
esac;

IFS=$OLDIFS
