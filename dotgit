#! /bin/bash

# Dotgit is an easy-to-use and effective way to backup all your dotfiles and manage them in a repository

# Written by Kobus van Schoor
# You are free to distrubute and modify this software in any way as long as you acknowledge the original author

REPO="$PWD"

function phelp
{
	echo "Usage: dotgit [option]

OPTIONS:
update			Update all the files in the repo with new versions from home folder
restore			Restore all files from the repo to your home folder
init			Initialize current folder with new dotgit repo
diff			Show new changes
help			Show this message"
}

function pstatus
{
	type="Updating"
	if [ ! -z $3 ]; then
		type="$3"
	fi;

	echo -n "-->$type    "; printf "%-30s" $1 $2; printf "\n"
}

function update
{
	if [ ! -e "$REPO/filelist" ]; then
		echo "Filelist not found. Aborting..."
		exit;
	fi;

	echo "Commencing update..."
	cd $HOME;

	for i in $(grep -v "\:" "$REPO/filelist"); do
		pstatus $i "common"
		cp --parents "$i" "$REPO/dotfiles/common"
	done;

	for i in $(grep "$HOSTNAME" "$REPO/filelist"); do
		hosts=$(echo $i | rev | sed s/\:.*// | sed s/\,/\ / | rev);
		filename=$(echo $i | sed s/\:.*//);
		for k in $hosts; do

			if [ ! -d "$REPO/dotfiles/$k" ]; then
				mkdir "$REPO/dotfiles/$k";
			fi;

			pstatus $filename $k
			cp --parents "$filename" "$REPO/dotfiles/$k"
		done;
	done;

	cd $REPO;
	cleanup

	if [ -z "$(git diff)" ]; then echo "No changes made to any files..."; exit; fi;

	echo -n "Do you want to create a commit for new update? [Y/n] "
	read ans
	if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
		echo -n "Do you want to generate a commit message? [Y/n] "
		read ans
		message="Changes: "
		if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
			OLDIFS=$IFS
			IFS=$(echo -ne "\n\b")
			for i in $(git diff --name-status | grep dotfiles); do
				case "$(echo $i | cut -c 1-1)" in
					"D")message=$(echo "$message deleted $(echo $i | cut -c 12-); ");;
					"M")message=$(echo "$message modified $(echo $i | cut -c 12-); ");;
				esac
			done
			IFS=$OLDIFS
			message=$(echo $message | rev | cut -c 2- | rev)
		else
			echo "Enter commit message:"
			read message
		fi
		git add --all
		git commit -m "$message"
	fi;
}

function cleanup
{
	echo "Commencing cleanup..."
	cd dotfiles;
	for i in *; do
		echo "Entering $i..."
		cd "$i"

		for k in $(find -not -type d); do
			if [ $k == "." ]; then
				continue;
			fi
			k=$(echo $k | cut -c 3-);

			z=""
			if [ $i != "common" ]; then
				z="$i"
			fi

			if [ -z "$(grep "$k" "$REPO/filelist" | grep "$z" )" ]; then
				pstatus "$k" "$i" "Removing"
				rm "$k"
			fi;
		done;
		cd ..
	done;

	cd $REPO;
	find dotfiles -empty -type d -delete
}

function restore
{

	echo asd;
}

function init
{
	echo "Initializing dotgit repo..."
	mkdir dotfiles
	mkdir dotfiles/common
	git init
	if [ ! -a filelist ]; then
		touch filelist
	fi
	echo "Initialized new dotgit repo in $PWD"
}

function pdiff
{
	git diff
}


if [[ $# -eq 0 ]]; then
	phelp;
	exit;
fi;

case "$1" in
	"update")update;;
	"restore")restore;;
	"init")init;;
	"diff")pdiff;;
	"help")phelp;;
	*)phelp;;
esac;
