#! /bin/bash

# Dotgit is an easy-to-use and effective way to backup all your dotfiles and manage them in a repository

# Written by Kobus van Schoor
# You are free to distrubute and modify this software in any way as long as you acknowledge the original author

REPO="$PWD"
OLDIFS=$IFS
IFS=$(echo -ne "\n\b")

function phelp
{
	echo "Usage: dotgit [option] (optional category)

OPTIONS:
  update		Update all the files in the repo with new versions from home folder
				If a category is passed to update only that category's files will be updated (not even the common folder will be updated)
  restore		Restore all files from the repo to your home folder
				If a category is passed to restore only that category's files will be restored (not even the common folder will be restored)
  add-remote	Add a url for an online repository to push (sync) files to (example https://github.com/Cube777/dotfiles)
  init			Initialize current folder with new dotgit repo
  diff			Show new changes
  help			Show this message"
}

function pstatus
{
	type="Updating"
	if [ ! -z $3 ]; then
		type="$3"
	fi;

	echo -n "-->$type    "; printf "%-30s" $1 $2; printf "\n"
}

function update
{
	if [ ! -e "$REPO/filelist" ]; then
		echo "Filelist not found. Aborting..."
		exit;
	fi;

	echo "Commencing update..."
	cd $HOME;

	if [ -z "$1" ]; then
		for i in $(grep -v "\:" "$REPO/filelist"); do
			pstatus $i "common"
			cp --parents "$i" "$REPO/dotfiles/common"
		done;

		for i in $(grep "$HOSTNAME" "$REPO/filelist"); do
			hosts=$(echo $i | rev | sed s/\:.*// | sed s/\,/\\n/ | rev);
			filename=$(echo $i | sed s/\:.*//);
			for k in $hosts; do

				if [ ! -d "$REPO/dotfiles/$k" ]; then
					mkdir "$REPO/dotfiles/$k";
				fi;

				pstatus $filename $k
				cp --parents "$filename" "$REPO/dotfiles/$k"
			done;
		done;
	else
		if [ ! -d "$REPO/dotfiles/$1" ]; then
			mkdir "$REPO/dotfiles/$1"
		fi

		for i in $(grep "$1" "$REPO/filelist"); do
			i=$(echo $i | sed s/\:.*//)
			pstatus "$i" "$1"
			cp --parents "$i" "$REPO/dotfiles/$1"
		done
	fi

	cd $REPO;
	cleanup

	git add --all
	if [ -z "$(git status --porcelain)" ]; then echo "No changes made to any files..."; return; fi;

	echo -n "Do you want to create a commit for new update? [Y/n] "
	read ans
	if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
		echo -n "Do you want to generate a commit message? [Y/n] "
		read ans
		message="Changes: "
		if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
			for i in $(git status --porcelain | grep dotfiles); do
				case "$(echo $i | cut -c 1-1)" in
					"D")message=$(echo "$message deleted $(echo $i | cut -c 13-); ");;
					"M")message=$(echo "$message modified $(echo $i | cut -c 13-); ");;
					"A")message=$(echo "$message added $(echo $i | cut -c 13-); ");;
					"R")message=$(echo "$message renamed $(echo $i | cut -c 4- | sed "s/dotfiles\///g"); ");;
				esac
			done
			IFS=$OLDIFS
			message=$(echo $message | rev | cut -c 2- | rev)
		else
			echo "Enter commit message:"
			read message
		fi
		git commit -m "$message"

		if [ ! -z "$(git remote)" ]; then
			echo -n "Remote detected, do you want to push (sync) to it? [Y/n] "
			read ans
			if [ -z "$ans" ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
				for i in $(git remote); do
					git push -u $i "$(git branch | grep \* | cut -c 3-)"
				done;
			fi
		fi
	else
		git reset
	fi
}

function cleanup
{
	echo "Commencing cleanup..."
	cd dotfiles;
	for i in *; do
		echo "Entering $i..."
		cd "$i"

		for k in $(find -not -type d); do
			if [ $k == "." ]; then
				continue;
			fi
			k=$(echo $k | cut -c 3-);

			z=""
			if [ $i != "common" ]; then
				z="$i"
			fi

			if [ -z "$(grep "$k" "$REPO/filelist" | grep "$z" )" ]; then
				pstatus "$k" "$i" "Removing"
				rm "$k"
			fi;
		done;
		cd ..
	done;

	cd $REPO;
	find dotfiles -empty -type d -delete
}

function restore
{
	echo "Commencing file restore..."
	cd dotfiles

	if [ -z "$1" ]; then
		cd common
		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "common" "Restoring"
			cp --parents "$i" "$HOME"
		done
		cd ..

		if [ -d "$HOSTNAME" ]; then
			cd "$HOSTNAME"
		else
			echo "Folder for $HOSTNAME not found..."
			echo "Finished restoring..."
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$HOSTNAME" "Restoring"
			cp --parents "$i" "$HOME"
		done
	else
		if [ -d "$1" ]; then
			cd "$1"
		else
			echo "Category $1 not found... Aborting"
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$1" "Restoring"
			cp --parents "$i" "$HOME"
		done
	fi

	echo "Finished restoring..."
}

function init
{
	echo "Initializing dotgit repo..."
	mkdir dotfiles
	mkdir dotfiles/common
	git init
	if [ ! -a filelist ]; then
		touch filelist
	fi
	echo "Initialized new dotgit repo in $PWD"
}

function pdiff
{
	git diff
}

function addRemote
{
	if [ -z "$1" ]; then
		echo "Error: you need to specify a remote repo"
		return
	fi

	if [ ! -z "$(git remote)" ]; then
		echo -n "This repository already has a remote repository to sync to (remote name $(git remote)), remove it? [Y/n] "
		read ans
		if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
			echo "Removed $(git remote)"
			git remote remove $(git remote)
		else
			echo "Aborting..."
			return
		fi
	fi

	git remote add origin "$1"
	echo "Added new repository $1"
}


if [[ $# -eq 0 ]]; then
	phelp;
	exit;
fi;

case "$1" in
	"update")update "$2";;
	"restore")restore "$2";;
	"init")init;;
	"diff")pdiff;;
	"help")phelp;;
	"add-remote")addRemote "$2";;
	*)phelp;;
esac;

IFS=$OLDIFS
