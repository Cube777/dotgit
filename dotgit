#! /bin/bash

# Dotgit is an easy-to-use and effective way to backup all your dotfiles and manage them in a repository

# Written by Kobus van Schoor
# You are free to distrubute and modify this software in any way as long as you acknowledge the original author

REPO="$PWD"
OLDIFS=$IFS
IFS=$(echo -ne "\n\b")

function phelp
{
	echo "Usage: dotgit [option] (optional category)

OPTIONS:
  update		Update all the files in the repo with new versions from home folder
				If a category is passed to update only that category's files will be updated (not even the common folder will be updated)
  restore		Restore all files from the repo to your home folder
				If a category is passed to restore only that category's files will be restored (not even the common folder will be restored)
  init			Initialize current folder with new dotgit repo
  diff			Show new changes
  help			Show this message"
}

function pstatus
{
	type="Updating"
	if [ ! -z $3 ]; then
		type="$3"
	fi;

	echo -n "-->$type    "; printf "%-30s" $1 $2; printf "\n"
}

function update
{
	if [ ! -e "$REPO/filelist" ]; then
		echo "Filelist not found. Aborting..."
		exit;
	fi;

	echo "Commencing update..."
	cd $HOME;

	if [ -z "$1" ]; then
		for i in $(grep -v "\:" "$REPO/filelist"); do
			pstatus $i "common"
			cp --parents "$i" "$REPO/dotfiles/common"
		done;

		for i in $(grep "$HOSTNAME" "$REPO/filelist"); do
			hosts=$(echo $i | rev | sed s/\:.*// | sed s/\,/\\n/ | rev);
			filename=$(echo $i | sed s/\:.*//);
			for k in $hosts; do

				if [ ! -d "$REPO/dotfiles/$k" ]; then
					mkdir "$REPO/dotfiles/$k";
				fi;

				pstatus $filename $k
				cp --parents "$filename" "$REPO/dotfiles/$k"
			done;
		done;
	else
		if [ ! -d "$REPO/dotfiles/$1" ]; then
			mkdir "$REPO/dotfiles/$1"
		fi

		for i in $(grep "$1" "$REPO/filelist"); do
			i=$(echo $i | sed s/\:.*//)
			pstatus "$i" "$1"
			cp --parents "$i" "$REPO/dotfiles/$1"
		done
	fi

	cd $REPO;
	cleanup

	if [ -z "$(git diff)" ]; then echo "No changes made to any files..."; exit; fi;

	echo -n "Do you want to create a commit for new update? [Y/n] "
	read ans
	if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
		echo -n "Do you want to generate a commit message? [Y/n] "
		read ans
		message="Changes: "
		if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
			for i in $(git diff --name-status | grep dotfiles); do
				case "$(echo $i | cut -c 1-1)" in
					"D")message=$(echo "$message deleted $(echo $i | cut -c 12-); ");;
					"M")message=$(echo "$message modified $(echo $i | cut -c 12-); ");;
				esac
			done
			IFS=$OLDIFS
			message=$(echo $message | rev | cut -c 2- | rev)
		else
			echo "Enter commit message:"
			read message
		fi
		git add --all
		git commit -m "$message"
	fi;
}

function cleanup
{
	echo "Commencing cleanup..."
	cd dotfiles;
	for i in *; do
		echo "Entering $i..."
		cd "$i"

		for k in $(find -not -type d); do
			if [ $k == "." ]; then
				continue;
			fi
			k=$(echo $k | cut -c 3-);

			z=""
			if [ $i != "common" ]; then
				z="$i"
			fi

			if [ -z "$(grep "$k" "$REPO/filelist" | grep "$z" )" ]; then
				pstatus "$k" "$i" "Removing"
				rm "$k"
			fi;
		done;
		cd ..
	done;

	cd $REPO;
	find dotfiles -empty -type d -delete
}

function restore
{
	echo "Commencing file restore..."
	cd dotfiles

	if [ -z "$1" ]; then
		cd common
		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "common" "Restoring"
			cp --parents "$i" "$HOME/qwe"
		done
		cd ..

		if [ -d "$HOSTNAME" ]; then
			cd "$HOSTNAME"
		else
			echo "Folder for $HOSTNAME not found..."
			echo "Finished restoring..."
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$HOSTNANE" "Restoring"
			cp --parents "$i" "$HOME/qwe"
		done
	else
		if [ -d "$1" ]; then
			cd "$1"
		else
			echo "Category $1 not found... Aborting"
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$1" "Restoring"
			cp --parents "$i" "$HOME/qwe"
		done
	fi

	echo "Finished restoring..."
}

function init
{
	echo "Initializing dotgit repo..."
	mkdir dotfiles
	mkdir dotfiles/common
	git init
	if [ ! -a filelist ]; then
		touch filelist
	fi
	echo "Initialized new dotgit repo in $PWD"
}

function pdiff
{
	git diff
}


if [[ $# -eq 0 ]]; then
	phelp;
	exit;
fi;

case "$1" in
	"update")update "$2";;
	"restore")restore "$2";;
	"init")init;;
	"diff")pdiff;;
	"help")phelp;;
	*)phelp;;
esac;

IFS=$OLDIFS
