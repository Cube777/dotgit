#! /bin/bash

# Dotgit is an easy-to-use and effective way to backup all your dotfiles and manage them in a repository

# Written by Kobus van Schoor
# You are free to distrubute and modify this software in any way as long as you acknowledge the original author

REPO="$PWD"
OLDIFS=$IFS
IFS=$(echo -ne "\n\b")

function phelp
{
	echo "Usage: dotgit [option] (optional args)

Filelist syntax:
  .bashrc             --  Will be in \"common\" folder and will be restored to home folder, regardless of hostname (unless category is specified)
  .vimrc:host1,host2  --  Will only be restored if hostname of machine matches \"host1\" or \"host2\"
  .vimrc:host3        --  Will be kept seperate from .vimrc above and will only be restored on host3
  .xinitrc:category1  --  When category1 is specified as category only files with category1 suffix will be restored (or backed up) (also excludes common folder)
  Comments are indicated with a // in the begining of the line (any line including // will be ignored, so don't use comments at the end of a line)

OPTIONS:
  update        --  If new files are added to the filelist, copy them to the repository and set up links in home folder
                    If a category is passed as an argument only the category's changes in the filelist will be taken into account
  restore       --  Set up links from repository in home folder
                    If a category is passed as an argument only the category's files will be linked into home folder
  generate      --  Generate a commit message, commit changes and push to remote
  add-remote    --  Add a url for an online repository to push (sync) files to (example https://github.com/Cube777/dotfiles)
  init          --  Initialize current folder with new dotgit repo (create empty filelist and dotfiles folder)
  diff          --  Show what files changed from previous commit in dotgit repository
  help          --  Show this message"
}

function ediff
{
	if [ ! -e $2 ]; then
		echo " (new file)"
		return
	fi

	if [ ! -z "$(diff "$1" "$2")" ]; then
		echo " (changed)"
	fi;
}

function pstatus
{
	type="Updating"
	if [ ! -z $3 ]; then
		type="$3"
	fi;

	echo -n "-->$type    "; printf "%-30s" $1 $2; printf "\n"
}

function update
{
	if [ ! -e "$REPO/filelist" ]; then
		echo "Filelist not found. Aborting..."
		exit;
	fi;

	if [ -z "$(grep -v "//" "$REPO/filelist")" ]; then
		echo "Filelist empty. Aborting..."
		exit
	fi

	if [ ! -d "$REPO/dotfiles" ]; then
		echo "Dotfiles folder not found. Aborting..."
		exit
	fi

	echo "Commencing update..."
	cd $HOME;

	if [ -z "$1" ]; then
		for i in $(grep -v "//" "$REPO/filelist" | grep -v "\:"); do
			pstatus $i "common$(ediff "$i" "$REPO/dotfiles/common/$i")"
			cp --parents "$i" "$REPO/dotfiles/common"
		done;

		for i in $(grep -v "//" "$REPO/filelist" | grep "$HOSTNAME"); do
			hosts=$(echo $i | rev | sed s/\:.*// | sed s/\,/\\n/g | rev);
			filename=$(echo $i | sed s/\:.*//);
			for k in $hosts; do
				if [ ! -d "$REPO/dotfiles/$k" ]; then mkdir "$REPO/dotfiles/$k"; fi

				pstatus "$filename" "$k$(ediff "$filename" "$REPO/dotfiles/$k/$filename")"
				cp --parents "$filename" "$REPO/dotfiles/$k"
			done;
		done;
	else
		if [ ! -d "$REPO/dotfiles/$1" ]; then
			mkdir "$REPO/dotfiles/$1"
		fi

		for i in $(grep -v "//" "$REPO/filelist" | grep "$1"); do
			i=$(echo $i | sed s/\:.*//)
			pstatus "$i" "$1$(ediff "$i" "$REPO/dotfiles/$1/$i")"
			cp --parents "$i" "$REPO/dotfiles/$1"
		done
	fi

	cd $REPO;
	cleanup

	git add --all
	if [ -z "$(git status --porcelain)" ]; then echo "No changes made to any files..."; return; fi;

	echo -n "Do you want to create a commit for new update? [Y/n] "
	read ans
	if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
		echo -n "Do you want to generate a commit message? [Y/n] "
		read ans
		message="Changes: "
		if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
			for i in $(git status --porcelain | grep dotfiles); do
				case "$(echo $i | cut -c 1-1)" in
					"D")message=$(echo "$message deleted $(echo $i | cut -c 13-); ");;
					"M")message=$(echo "$message modified $(echo $i | cut -c 13-); ");;
					"A")message=$(echo "$message added $(echo $i | cut -c 13-); ");;
					"R")message=$(echo "$message renamed $(echo $i | cut -c 4- | sed "s/dotfiles\///g"); ");;
				esac
			done
			IFS=$OLDIFS
			message=$(echo $message | rev | cut -c 2- | rev)
		else
			echo "Enter commit message:"
			read message
		fi
		git commit -m "$message"

		if [ ! -z "$(git remote)" ]; then
			echo -n "Remote detected, do you want to push (sync) to it? [Y/n] "
			read ans
			if [ -z "$ans" ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
				for i in $(git remote); do
					git push -u $i "$(git branch | grep \* | cut -c 3-)"
				done;
			fi
		fi
	else
		git reset -q
	fi
}

function cleanup
{
	echo "Commencing cleanup..."

	cd dotfiles
	for i in *; do
		echo "Entering $i..."
		cd "$i"

		for k in $(find -not -type d); do
			if [ $k == "." ]; then
				continue;
			fi
			k=$(echo $k | cut -c 3-);

			z=""
			if [ $i != "common" ]; then
				z="$i"
			fi

			if [ -z "$(grep -v "//" "$REPO/filelist" | grep "$k" | grep "$z" )" ]; then
				pstatus "$k" "$i" "Removing"
				rm "$k"
			fi;
		done;
		cd ..
	done;

	cd $REPO;
	find dotfiles -empty -type d -delete
}

function confcpy
{
	if [ -f "$HOME/$1" ]; then
		if [ ! -z "$(diff "$i" "$HOME/$i")" ]; then
			echo -ne "File $1 already exist in $HOME, and differs from the one in this repository.\nDo you want to replace it? [N/y]: "
			read ans
			if [ $ans == "y" ] || [ $ans == "Y" ]; then
				cp --parents "$1" "$HOME"
			fi
		fi
	else
		cp --parents "$1" "$HOME"
	fi
}

function restore
{
	echo "Commencing file restore..."
	cd dotfiles

	if [ -z "$1" ]; then
		cd common
		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "common" "Restoring"
			confcpy "$i"
		done
		cd ..

		if [ -d "$HOSTNAME" ]; then
			cd "$HOSTNAME"
		else
			echo "Folder for $HOSTNAME not found..."
			echo "Finished restoring..."
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$HOSTNAME" "Restoring"
			confcpy "$i"
		done
	else
		if [ -d "$1" ]; then
			cd "$1"
		else
			echo "Category $1 not found... Aborting"
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			pstatus "$i" "$1" "Restoring"
			confcpy "$i"
		done
	fi

	echo "Finished restoring..."
}

function init
{
	echo "Initializing dotgit repo..."
	mkdir dotfiles
	mkdir dotfiles/common
	git init
	if [ ! -a filelist ]; then
		touch filelist
	fi
	echo "Initialized new dotgit repo in $PWD"
}

function pdiff
{
	for i in $(grep -v "//" "$REPO/filelist" | grep -v "\:"); do
		z=$(ediff "$HOME/$i" "$REPO/dotfiles/common/$i")

		if [ ! -z "$z" ]; then
			z=$(echo "common/$i $z")
			echo $z
		fi
	done

	for i in $(grep -v "//" "$REPO/filelist" | grep $HOSTNAME); do
		i=$(echo $i | sed s/\:.*//)
		z=$(ediff "$HOME/$i" "$REPO/dotfiles/$HOSTNAME/$i")

		if [ ! -z "$z" ]; then
			z=$(echo "$HOSTNAME/$i $z")
			echo $z
		fi
	done
}

function addRemote
{
	if [ -z "$1" ]; then
		echo "Error: you need to specify a remote repo"
		return
	fi

	if [ ! -z "$(git remote)" ]; then
		echo -n "This repository already has a remote repository to sync to (remote name $(git remote)), remove it? [Y/n] "
		read ans
		if [ -z $ans ] || [ $ans == 'Y' ] || [ $ans == 'y' ]; then
			echo "Removed $(git remote)"
			git remote remove $(git remote)
		else
			echo "Aborting..."
			return
		fi
	fi

	git remote add origin "$1"
	echo "Added new repository $1"
}


if [[ $# -eq 0 ]]; then
	phelp;
	exit;
fi;

case "$1" in
	"update")update "$2";;
	"restore")restore "$2";;
	"init")init;;
	"diff")pdiff;;
	"help")phelp;;
	"add-remote")addRemote "$2";;
	*)echo -e "\n$1 is not a valid argument.\n"; phelp;;
esac;

IFS=$OLDIFS
