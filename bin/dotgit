#! /bin/bash

# Dotgit is an easy-to-use and effective way to backup all your dotfiles and
# manage them in a repository

# Developer: Kobus van Schoor

REPO="$PWD"
DOTFILES=""
DMZ=""

DG_H=$(dirname "$(readlink -f "$0")")/dotgit_headers

source "$DG_H/files"
source "$DG_H/help"
source "$DG_H/init"
source "$DG_H/prompts"
source "$DG_H/security"
source "$DG_H/update"

function yesno
{
	echo -n $* "[Y/n]: "
	read ans

	if [ "$ans" == "Y" ] || [ "$ans" == "y" ] || [ -z "$ans" ]; then
		return 1
	else
		return 0
	fi
}

function lnconf
{
	if [ -h "$2" ]; then
		rm "$2"
	fi

	if [ -f "$2" ] && [ ! -h "$2" ]; then
		yesno "File $3 already exists in home directory. Do you want to"\
			"overwrite it?"

		if [ "$?" == 1 ]; then
			rm "$2"
		else
			return
		fi
	fi
	ln -s "$1" "$2"
}

function restore
{
	if [ -f "$REPO/hard" ]; then hardrestore; return; fi

	cleanhome
	echo "Commencing unencrypted repo linking..."
	homelink "$DOTFILES" "$1" "${NORMFILES[@]}"
	echo "Commencing encrypted repo linking..."
	homelink "$DMZ" "$1" "${CRYPTFILES[@]}"
}

function homelink
{
	FILELIST=${@:3}
	CDFILES=$1

	cd "$CDFILES"
	owner=$2

	if [ -z "$owner" ]; then
		for i in ${FILELIST[@]}; do
			if [[ $i =~ : ]]; then continue; fi
			if [ "$(dirname "$i")" != "." ]; then
				mkdir -p "$(dirname "$HOME/$i")"
			fi

			if [ ! -f "$CDFILES/common/$i" ]; then
				echo "-->Can't link $i (its either not yet decrypted or it has"\
					"not been copied to the repository yet)"
				continue
			fi

			lnconf "$CDFILES/common/$i" "$HOME/$i" "$i"
		done
		owner=$HOSTNAME
	fi

	for i in ${FILELIST[@]}; do
		if ! [[ $i =~ $owner ]]; then continue; fi
		ownrs=($(echo $i | rev | sed s/\:.*// | sed s/\,/\ /g | rev))
		ownrs=($(for z in ${ownrs[@]}; do echo $z; done | sort))
		filename=$(echo $i | sed s/\:.*//);

		if [ ! -f "$CDFILES/${ownrs[0]}/$filename" ]; then
			echo "-->Can't link $filename (its either not yet decrypted or it"\
				"has not been copied to the repository yet)"
			continue
		fi

		if [ "$(dirname "$filename")" != "." ]; then
			mkdir -p "$(dirname "$HOME/$filename")"
		fi

		lnconf "$CDFILES/${ownrs[0]}/$filename" "$HOME/$filename" \
		"$filename"
	done
}

function generate
{
	encrypt
	cd "$REPO"
	git add --all
	OLDIFS=$IFS
	IFS=$(echo -en '\n')
	message=$(git status --porcelain | grep "dotfiles" | grep -v '.hash' | \
		tr '\n' ';')
	IFS=$OLDIFS

	message=$(echo $message |  sed 's/;/;\ /g')

	message=$(echo $message | \
		sed 's/dotfiles\///g' | \
		sed 's/A/added/g' | \
		sed 's/R/renamed/g' | \
		sed 's/M/modified/g' | \
		sed 's/D/deleted/g' | \
		sed 's/C/copied/g' | \
		sed 's/T/typechanged/g')

	if [ -z "$message" ]; then
		echo "No changes to repository..."
		return
	fi

	git commit -m "Changes: $(echo "$message" | rev | cut -c 2- | rev)"

	if [ -n "$(git remote -v)" ]; then
		yesno "Remote detected, do you want to push (sync) to it?"
		if [ "$?" == 1 ]; then
			git push
		fi
	fi
}

function cleanup
{
	CDFILES=$1
	FILELIST=${@:2}

	if [ -z "$(ls -A $CDFILES)" ]; then
		return
	fi

	cd "$CDFILES"
	for i in *; do
		echo "Cleanup - entering $i..."
		cd "$i"

		find -not -type d | while read k; do
			k=$(echo $k | cut -c 3-);

			z=
			if [ "$i" != "common" ]; then
				z="$i"
			fi

			h=0
			if [[ $k =~ .hash ]]; then
				k=$(echo $k | sed 's/\.hash//')
				h=1
			fi

			if [ -n "$z" ]; then
				flag=0
				for f in ${FILELIST[@]}; do
					only=$k:$z\$
					first=$k:$z,
					mid=$k:.\*,$z,
					last=$k:.\*,$z\$

					if [[ $f =~ $only ]] || [[ $f =~ $first ]] || \
						[[ $f =~ $mid ]] || [[ $f =~ $last ]]; then
						flag=1
						break;
					fi
				done

				if [ $flag == 0 ]; then
					if [ $h == 1 ]; then k="$k.hash"; fi
					pstatus "$i/$k" "$i" "Removing"
					rm "$k"
				fi;
			else
				flag=0
				for f in ${FILELIST[@]}; do
					reg="^$k\$"
					if [[ $f =~ $reg ]]; then
						flag=1
						break
					fi
				done

				if [ $flag == 0 ]; then
					if [ $h == 1 ]; then k="$k.hash"; fi
					pstatus "$i/$k" "$i" "Removing"
					rm "$k"
				fi
			fi
		done;
		cd "$CDFILES"
	done;

	find "$CDFILES" -not -name "$(basename $CDFILES)" -and -empty -and -type d \
	-delete
}

function cleanhome
{
	echo "Cleaning up old repo links..."
	for i in $(find $HOME -type l -not -wholename "$REPO/*"); do
		if [[ `readlink $i` =~ $REPO ]]; then rm $i; fi
	done
}

function hardrestore
{
	echo "Commencing hard restore of normal files..."
	copytohome "$DOTFILES" "$1" "${NORMFILES[@]}"
	echo "Commencing hard restore of encrypted files..."
	copytohome "$DMZ" "$1" "${CRYPTFILES[@]}"
}

function copytohome
{
	FILELIST=${@:3}
	CDFILES=$1
	category=$2

	cd "$CDFILES"

	if [ -z "$category" ]; then
		if [ -d common ]; then
			cd common
			for i in $(find . -not -type d); do
				i="$(echo $i | cut -c 3-)"
				if [[ $i =~ .hash ]]; then continue; fi
				if ! echo "${FILELIST[@]}" | grep -q "$i"; then continue; fi
				pstatus "$i" "common" "Copying"
				if [ -f "$HOME/$i" ]; then
					rm "$HOME/$i"
				fi
				cp --parents "$i" "$HOME"
			done
			cd ..
		fi

		if [ -d "$HOSTNAME" ]; then
			cd "$HOSTNAME"
		else
			echo "Folder for $HOSTNAME not found..."
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			if [[ $i =~ .hash ]]; then continue; fi
			if ! echo ${FILELIST[@]} | grep -q "$i.*$HOSTNAME"; then
				continue; fi
			pstatus "$i" "$HOSTNAME" "Copying"
			if [ -f "$HOME/$i" ]; then
				rm "$HOME/$i"
			fi
			cp -L --parents "$i" "$HOME"
		done
	else
		if [ -d "$category" ]; then
			cd "$category"
		else
			echo "Category $category not found..."
			return
		fi

		for i in $(find . -not -type d); do
			i="$(echo $i | cut -c 3-)"
			if [[ $i =~ .hash ]]; then continue; fi
			if ! echo ${FILELIST[@]} | grep -q "$i.*$category"; then
				continue; fi
			if ! echo "${FILELIST[@]}" | grep -q "$i"; then continue; fi
			pstatus "$i" "$category" "Copying"
			if [ -f "$HOME/$i" ]; then
				rm "$HOME/$i"
			fi
			cp -L --parents "$i" "$HOME"
		done
	fi

	echo "Finished copying..."
}

function init
{
	echo "Initializing dotgit repo..."
	if [ ! -d "$REPO/.git" ]; then git init; fi
	touch filelist
	touch cryptlist
	touch dir_filelist
	touch dir_cryptlist

	ignore=0
	if [ -f "$REPO/.gitignore" ]; then
		if ! grep -q "dmz" "$REPO/.gitignore"; then
			ignore=1
		fi
	else
		ignore=1
	fi

	if [ $ignore -eq 1 ]; then
		echo "dmz" >> .gitignore
		echo "tmp" >> .gitignore
		echo "mid" >> .gitignore
		echo "unsafe" >> .gitignore
	fi

	create=0
	if [ -f "$REPO/.git/hooks/post-merge" ]; then
		if ! grep -q "dotgit decrypt" "$REPO/.git/hooks/post-merge"; then
			create=1
		fi
	else
		create=1
	fi

	if [ $create -eq 1 ]; then
		echo "Creating encryption hooks..."
		echo "exec < /dev/tty" >> .git/hooks/post-merge
		echo "dotgit decrypt" >> .git/hooks/post-merge
		chmod +x .git/hooks/post-merge
	fi

	mkdir -p $REPO/dotfiles
	mkdir -p $REPO/dmz

	echo "Initialized dotgit repo in $PWD"
}

function pdiff
{
	cd "$REPO"
	git add --all
	OLDIFS=$IFS
	IFS=$(echo -en '\n')
	message=$(git status --porcelain | grep "dotfiles" | grep -v '.hash')

	message=$(echo $message | \
		sed 's/dotfiles\///g' | \
		sed 's/A/Added/g' | \
		sed 's/R/Renamed/g' | \
		sed 's/M/Modified/g' | \
		sed 's/D/Deleted/g' | \
		sed 's/C/Copied/g' | \
		sed 's/T/Typechange/g')

	if [ -z "$message" ]; then
		echo "No changes to dotfiles folder..."
	else
		echo "$message"
	fi
	IFS=$OLDIFS

	message=""
	for i in $(find "$DMZ" -not -type l -and -not -type d); do
		i=$(echo $i | cut -c `expr ${#DMZ} + 2`-)
		if [ -f "$DOTFILES/$i.hash" ]; then
			sum=$(sha256sum "$DMZ/$i" | sed 's/\ .*//')
			comp=$(cat "$DOTFILES/$i.hash")
			if [ $comp != $sum ]; then
				message=$(echo -e "$message" "\nModified $i")
			fi
		else
			message=$(echo -e "$message" "\nAdded $i")
		fi
	done

	if [ -n "$message" ]; then
		echo -e "\nUnencrypted changes (does not show removed files):"\
			"$message\n"
	fi

	git reset -q
}

function ext
{
	# IFS=$PIFS
	if [ -f "$REPO/tmp" ]; then
		rm "$REPO/tmp"
	fi
	stty sane

	if [ -z "$1" ]; then
		exit 1
	else
		exit $1
	fi
}

if [[ $# -eq 0 ]]; then
	phelp;
	exit;
fi;

if [[ $1 != "init" ]]; then cfilelist "$1" "$2"; fi
safeguards $1

trap ext SIGINT

case "$1" in
	"update")update "$2";;
	"restore")restore "$2";;
	"generate")generate;;
	"hard-restore")hardrestore "$2";;
	"init")init;;
	"encrypt")encrypt;;
	"decrypt")decrypt;;
	"clean")cleanhome;;
	"passwd")passwd;;
	"diff")pdiff;;
	"help")phelp;;
	*)echo -e "$1 is not a valid argument."; exit 1;;
esac;

ext 0
