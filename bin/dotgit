#! /bin/bash

# Dotgit is an easy-to-use and effective way to backup all your dotfiles and
# manage them in a repository

# Developer: Kobus van Schoor

REPO="$PWD"
DOTFILES=""
DMZ=""

DG_H=$(dirname "$(readlink -f "$0")")/dotgit_headers

source "$DG_H/files"
source "$DG_H/help"
source "$DG_H/init"
source "$DG_H/prompts"
source "$DG_H/security"
source "$DG_H/update"
source "$DG_H/restore"

function generate
{
	encrypt
	cd "$REPO"
	git add --all
	OLDIFS=$IFS
	IFS=$(echo -en '\n')
	message=$(git status --porcelain | grep "dotfiles" | grep -v '.hash' | \
		tr '\n' ';')
	IFS=$OLDIFS

	message=$(echo $message |  sed 's/;/;\ /g')

	message=$(echo $message | \
		sed 's/dotfiles\///g' | \
		sed 's/A/added/g' | \
		sed 's/R/renamed/g' | \
		sed 's/M/modified/g' | \
		sed 's/D/deleted/g' | \
		sed 's/C/copied/g' | \
		sed 's/T/typechanged/g')

	if [ -z "$message" ]; then
		echo "No changes to repository..."
		return
	fi

	git commit -m "Changes: $(echo "$message" | rev | cut -c 2- | rev)"

	if [ -n "$(git remote -v)" ]; then
		yesno "Remote detected, do you want to push (sync) to it?"
		if [ "$?" == 1 ]; then
			git push
		fi
	fi
}

function cleanup
{
	CDFILES=$1
	FILELIST=${@:2}

	if [ -z "$(ls -A $CDFILES)" ]; then
		return
	fi

	cd "$CDFILES"
	for i in *; do
		echo "Cleanup - entering $i..."
		cd "$i"

		find -not -type d | while read k; do
			k=$(echo $k | cut -c 3-);

			z=
			if [ "$i" != "common" ]; then
				z="$i"
			fi

			h=0
			if [[ $k =~ .hash ]]; then
				k=$(echo $k | sed 's/\.hash//')
				h=1
			fi

			if [ -n "$z" ]; then
				flag=0
				for f in ${FILELIST[@]}; do
					only=$k:$z\$
					first=$k:$z,
					mid=$k:.\*,$z,
					last=$k:.\*,$z\$

					if [[ $f =~ $only ]] || [[ $f =~ $first ]] || \
						[[ $f =~ $mid ]] || [[ $f =~ $last ]]; then
						flag=1
						break;
					fi
				done

				if [ $flag == 0 ]; then
					if [ $h == 1 ]; then k="$k.hash"; fi
					pstatus "$i/$k" "$i" "Removing"
					rm "$k"
				fi;
			else
				flag=0
				for f in ${FILELIST[@]}; do
					reg="^$k\$"
					if [[ $f =~ $reg ]]; then
						flag=1
						break
					fi
				done

				if [ $flag == 0 ]; then
					if [ $h == 1 ]; then k="$k.hash"; fi
					pstatus "$i/$k" "$i" "Removing"
					rm "$k"
				fi
			fi
		done;
		cd "$CDFILES"
	done;

	find "$CDFILES" -not -name "$(basename $CDFILES)" -and -empty -and -type d \
	-delete
}

function cleanhome
{
	echo "Cleaning up old repo links..."
	for i in $(find $HOME -type l -not -wholename "$REPO/*"); do
		if [[ `readlink $i` =~ $REPO ]]; then rm $i; fi
	done
}

function init
{
	echo "Initializing dotgit repo..."
	if [ ! -d "$REPO/.git" ]; then git init; fi
	touch filelist
	touch cryptlist
	touch dir_filelist
	touch dir_cryptlist

	ignore=0
	if [ -f "$REPO/.gitignore" ]; then
		if ! grep -q "dmz" "$REPO/.gitignore"; then
			ignore=1
		fi
	else
		ignore=1
	fi

	if [ $ignore -eq 1 ]; then
		echo "dmz" >> .gitignore
		echo "tmp" >> .gitignore
		echo "mid" >> .gitignore
		echo "unsafe" >> .gitignore
	fi

	create=0
	if [ -f "$REPO/.git/hooks/post-merge" ]; then
		if ! grep -q "dotgit decrypt" "$REPO/.git/hooks/post-merge"; then
			create=1
		fi
	else
		create=1
	fi

	if [ $create -eq 1 ]; then
		echo "Creating encryption hooks..."
		echo "exec < /dev/tty" >> .git/hooks/post-merge
		echo "dotgit decrypt" >> .git/hooks/post-merge
		chmod +x .git/hooks/post-merge
	fi

	mkdir -p $REPO/dotfiles
	mkdir -p $REPO/dmz

	echo "Initialized dotgit repo in $PWD"
}

function pdiff
{
	cd "$REPO"
	git add --all
	OLDIFS=$IFS
	IFS=$(echo -en '\n')
	message=$(git status --porcelain | grep "dotfiles" | grep -v '.hash')

	message=$(echo $message | \
		sed 's/dotfiles\///g' | \
		sed 's/A/Added/g' | \
		sed 's/R/Renamed/g' | \
		sed 's/M/Modified/g' | \
		sed 's/D/Deleted/g' | \
		sed 's/C/Copied/g' | \
		sed 's/T/Typechange/g')

	if [ -z "$message" ]; then
		echo "No changes to dotfiles folder..."
	else
		echo "$message"
	fi
	IFS=$OLDIFS

	message=""
	for i in $(find "$DMZ" -not -type l -and -not -type d); do
		i=$(echo $i | cut -c `expr ${#DMZ} + 2`-)
		if [ -f "$DOTFILES/$i.hash" ]; then
			sum=$(sha256sum "$DMZ/$i" | sed 's/\ .*//')
			comp=$(cat "$DOTFILES/$i.hash")
			if [ $comp != $sum ]; then
				message=$(echo -e "$message" "\nModified $i")
			fi
		else
			message=$(echo -e "$message" "\nAdded $i")
		fi
	done

	if [ -n "$message" ]; then
		echo -e "\nUnencrypted changes (does not show removed files):"\
			"$message\n"
	fi

	git reset -q
}

function ext
{
	# IFS=$PIFS
	if [ -f "$REPO/tmp" ]; then
		rm "$REPO/tmp"
	fi
	stty sane

	if [ -z "$1" ]; then
		exit 1
	else
		exit $1
	fi
}

if [[ $# -eq 0 ]]; then
	phelp;
	exit;
fi;

if [[ $1 != "init" ]]; then cfilelist "$1" "$2"; fi
safeguards $1

trap ext SIGINT

case "$1" in
	"update")update "$2";;
	"restore")restore "$2";;
	"generate")generate;;
	"hard-restore")hardrestore "$2";;
	"init")init;;
	"encrypt")encrypt;;
	"decrypt")decrypt;;
	"clean")cleanhome;;
	"passwd")passwd;;
	"diff")pdiff;;
	"help")phelp;;
	*)echo -e "$1 is not a valid argument."; exit 1;;
esac;

ext 0
